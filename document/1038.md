1038 - 감소하는 수
===
<img src="https://t1.daumcdn.net/liveboard/ssully/4c65d393ece34c0fa1182d7d479697d8.JPG">

**이 문서는 멍청한 사람이 풀어보다 오류를 발견하고 기운이 빠져 작성한 문서입니다.**

(아마) 제가 풀려고 시도해본 첫 골드 문제(at solved.ac)입니다.  
제 불찰로 문제를 파악하지 못하고 왜 틀렸냐를 남발하던 도중 숫자의 상태를 보고.. 그만 정신을 잃고 말았습니다...

우선 문제를 보러 갑시다

## 그래서 하락.. 아니 감소하는 수가 뭔데?

우선 1~9까지는 모두 하락하는 수로 가정합니다.  
10~∞까지 중 아래와 같은 경우를 하락하는 수로 가정합니다.

```
10
20
21
30
31
32
...
```

대충 자리수를 

## 구현해보자!

우선 가장 큰 감소하는 수는 9,876,543,210입니다. 그리고 이 수는 1022번째 감소하는 수입니다. 따라서 1023번째 이상으로는 -1을 출력합니다.

그리고, 이 수 ```9,876,543,210```은 ```int```형의 양수 최댓값인 ```2,147,483,647```를 2배를 훨씬 넘어섭니다!

고로, 음수값을 생각하지 않는 문제여서 앞에 ```unsigned```를 붙혀도, 최댓값이 ```4,294,967,294``` 부근에서만 놀 수 있습니다. **절대적으로 부족합니다.**

그래서 ~~낭낭하게~~ 양수값 최댓값이 ```18,446,744,073,709,551,615```인데다, 혹시 몰라 음수값이 튀어나올 여지 없는 ```unsigned long```을 사용 할 예정입니다.

참고로 입력을 받는 0 ≤ N ≤ 1,000,000이므로, int 범위를 만족합니다.

```cpp
...
int n;

int main() {
    cin >> n;

    if(n > 1022) {
        cout << -1;
    } else if (n > 10) {
        //계산 할 부분
    } else {
        cout << n;
    }
}
```

## 효율성을 되찾자
사실 이 문제는 제가 한번 틀리고, 한번은 시간 초과가 떴습니다.

좀 더 시간을 줄일 수 있을까 싶어 폭풍검색을 합니다. 역시 사람들은 똑똑합니다.

**이미 만들어진 감소하는 수로 새로운 감소하는 수를 만드는 방법이 있던겁니다!**

```
A. 먼저 0~9까지 선언
0
1
2
3
...
9

B. 0~9로 새로운 감소하는 수의 수열 만들기
0은 패스 (없음)

1을 뽑아내서
10

2를 뽑아내서
20, 21

...

9를 뽑아내서
98, 97 ... 90

C. B에서 만든 수열로 새로운 감소하는 수의 수열 만들기

10 * n 은 패스 (100 * n 은 감소하는 수열이 될 수 없다.)

21을 뽑아내서
210

31을 뽑아내서
310

32를 뽑아내서
320
321

...

987,654,321을 뽑아내서
9,876,543,210 < 마지막 감소하는 수>
```

역시 구글의 검색 엔진은 제 마음을 만족시킵니다. 바로 이 방식으로 전향합니다.

> 작성중
